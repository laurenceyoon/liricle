{"version":3,"file":"liricle.min.js","sources":["../src/parser.js","../src/sync.js","../src/liricle.js"],"sourcesContent":["// will match: \"[tag:value]\"\nconst TAGS_REGEX = /\\[([a-z]+):(.*)\\]/i;\n\n// will match: \"<00:00.00> blablabla\"\nconst WORD_REGEX = /<\\d{2}:\\d{2}(.\\d{2,})?>\\s*[^\\s|<]*/g;\n\n// will match: \"[00:00.00]\"\nconst LINE_TIME_REGEX = /\\[\\d{2}:\\d{2}(.\\d{2,})?\\]/g;\n\n// will match: \"<00:00.00>\"\nconst WORD_TIME_REGEX = /<\\d{2}:\\d{2}(.\\d{2,})?>/g;\n\n/**\n * parse lrc to javascript object\n * @param {string} text - lrc text\n * @returns {Object} parsed data from lrc\n */\nexport default function parser(text) {\n      const lines = text.split(/\\r?\\n/);\n      \n      const output = {\n            tags: {},\n            lines: [],\n            enhanced: isEnhanced(text)\n      };\n\n      // parsing started\n      lines.forEach(value => {\n            const tags = extractTags(value);\n            const line = extractLine(value);\n\n            if (tags) output.tags[tags.name] = tags.value;\n            if (line) output.lines.push(...line);\n      });\n\n      // if lrc has multiple time in the same line \n      // parser will split them into individual lines \n      // so we have to reorder them.\n      output.lines = sortLines(output.lines);\n\n      return output;\n}\n\n/**\n * extract tag data from lrc\n * @param {string} text - lrc line\n * @return {(Object|undefined)} extrated tag object or undefined\n */\n function extractTags(text) {\n      const tags = text.match(TAGS_REGEX);\n\n      if (!tags) return;\n\n      return { \n            name: tags[1], \n            value: tags[2].trim() \n      };\n}\n\n/**\n * extract time, text and words from lrc\n * @param {string} line - lrc line\n * @return {(Array|undefined)} array that contains lrc line object or undefined\n */\n function extractLine(line) {\n      const times = line.match(LINE_TIME_REGEX);\n      const bucket = [];\n\n      if (!times) return;\n\n      times.forEach(value => {\n            bucket.push({\n                  time: extractTime(value),\n                  text: extractText(line),\n                  words: extractWords(line),\n            });\n      });\n\n      return bucket;\n}\n\n/**\n * extract time from lrc line and convert to seconds\n * @param {string} line - time string \"[mm:ss.xx]\"\n * @returns {number} extracted time number in seconds\n */\n function extractTime(line) {\n      let time = line.replace(/\\[|\\]|<|>/g, \"\");\n      time = convertTime(time);\n\n      return time;\n}\n\n/**\n * extract words from lrc line\n * @param {string} line - lrc line\n * @returns {(Array|null)} extracted words or null\n */\n function extractWords(line) {\n      const words = line.match(WORD_REGEX);\n      const bucket = [];\n\n      if (!words) return null;\n\n      words.forEach(value => {\n            // extract timestamp \"<00:00.00>\" with regex\n            // i think it's easier than split them\n            const time = value.match(WORD_TIME_REGEX)[0];\n\n            bucket.push({\n                  time: extractTime(time),\n                  text: extractText(value),\n            });\n      });\n\n      return bucket;\n}\n\n/**\n * extract text from lrc line\n * @param {string} line - lrc line\n * @returns {string} extracted text\n */\n function extractText(line) {\n      let text = line.replace(LINE_TIME_REGEX, \"\");\n      text = text.replace(WORD_TIME_REGEX, \"\");\n\n      return text.trim();\n}\n\n/**\n * convert \"[03:24.73]\" to 204.73 (total time in seconds)\n * @param {string} time - time string \"mm:ss.xx\"\n * @returns {number} total time in seconds\n */\n function convertTime(time) {\n      let [min, sec] = time.split(\":\");\n\n      min = parseFloat(min) * 60;\n      sec = parseFloat(sec);\n\n      return min + sec;\n}\n\n/**\n * sort lines by time (shortest to longest)\n * @param {Array} lines - parsed lrc lines\n * @returns {Array} sorted lines\n */\nfunction sortLines(lines) {\n      return lines.sort((a, b) => a.time - b.time);\n}\n\n/**\n * check the lrt format is enhanced or not\n * @param {string} text - lrc text\n * @returns {boolean} is enhanced?\n */\nfunction isEnhanced(text) {\n      return WORD_TIME_REGEX.test(text);\n}","/**\n * find closest lyric word and line from given time\n * @param {Object} data - output data from parser\n * @param {number} time - current time from audio player or something else\n */\nexport default function sync(data, time) {\n      let line = null;\n      let word = null;\n\n      const lines = data.lines;\n      line = findLine(lines, time);\n\n      if (line != null && data.enhanced) {\n            const words = line.words;\n            word = findWord(words, time);\n\n            // delete 'words' property from line\n            // because we don't need it anymore.\n            delete line.words;\n      }\n\n      return { line, word };\n}\n\n/**\n * find closest lyric line\n * @param {Array} lines - array that contains lyric lines\n * @param {number} time - time argument of the sync function\n * @returns {(Object|null)} closest lyric line or null\n */\nfunction findLine(lines, time) {\n      const index = getClosestIndex(lines, time);\n      return index != null ? { index, ...lines[index] } : null;\n}\n\n/**\n * find closest lyric word\n * @param {Array} words - array that contains lyric words\n * @param {number} time - time argument of the sync function\n * @returns {(Object|null)} closest lyric word or null\n */\nfunction findWord(words, time) {\n      // if words are null, just return it.\n      if (words == null) return words;\n\n      const index = getClosestIndex(words, time);\n      return index != null ? { index, ...words[index] } : null;\n}\n\n/**\n * \n * @param {Array} items - array that contains lyric words or lines\n * @param {number} time - time argument of the sync function\n * @returns {(number|null)} closest index of lyric or null\n */\nfunction getClosestIndex(items, time) {\n      // to find the closest index we just need to subtract each line or word time with the given time\n      // then put the value into an array and find the smallest positive value with Math.min()\n      // after that we can find the index from smallest value in array with indexOf() method.\n\n      const scores = [];\n\n      items.forEach(item => {\n            const score = time - item.time;\n            if (score >= 0) scores.push(score);\n      });\n\n      if (scores.length == 0) return null;\n\n      const smallest = Math.min(...scores);\n      const index = scores.indexOf(smallest);\n\n      return index;\n}\n","import parser from \"./parser.js\";\nimport sync from \"./sync.js\";\n\nexport default class Liricle {\n      #activeLine = null;\n      #activeWord = null;\n      #onInit = () => {};\n      #onSync = () => {};\n\n      constructor() {\n            this.data = null;\n      }\n\n      /**\n       * initialize Liricle\n       * @param {Object} options\n       * @param {string} options.text - lrc text\n       * @param {string} options.url - lrc file url\n       */\n      async init(options) {            \n            if (options && options.url) {\n                  try {\n                        const resp = await fetch(options.url);\n\n                        if (!resp.ok) {\n                              throw Error(`${resp.status} ${resp.statusText} (${resp.url})`);\n                        }\n\n                        const body = await resp.text();\n                        this.data = parser(body);\n                  } \n                  \n                  catch (error) {\n                        throw Error(`Liricle.init(): ${error.message}`);\n                  }\n            } \n\n            else if (options && options.text) {\n                  this.data = parser(options.text);\n            } \n            \n            else {\n                  throw Error(`Liricle.init(): missing argument`);\n            }\n            \n            this.#onInit(this.data);\n      }\n\n      /**\n       * sync lyric with current time\n       * @param {number} time - currrent time from audio player or something else in seconds\n       * @param {number} offset - lyric offset in seconds\n       * @param {boolean} continuous - always emit sync event \n       */\n      sync(time, offset = 0, continuous = false) {\n            if (time == undefined) {\n                  throw Error(\"Liricle.sync(): missing 'time' argument\");\n            }\n\n            if (typeof time != \"number\") {\n                  throw Error(\"Liricle.sync(): 'time' argument must be a number!\");\n            }\n\n            if (typeof offset != \"number\") {\n                  throw Error(\"Liricle.sync(): 'offset' argument must be a number!\");\n            }\n\n            if (typeof continuous != \"boolean\") {\n                  throw Error(\"Liricle.sync(): 'continuous' argument must be a boolean!\");\n            }\n\n            const { line, word } = sync(this.data, time + offset);\n            \n            if (line == null && word == null) return;\n\n            if (this.data.enhanced && word != null) {\n                  if (\n                        continuous == false &&\n                        line.index == this.#activeLine &&\n                        word.index == this.#activeWord\n                  ) return;\n\n                  this.#activeLine = line.index;\n                  this.#activeWord = word.index;\n            }\n\n            else {\n                  if (\n                        continuous == false &&\n                        line.index == this.#activeLine\n                  ) return;\n                  \n                  this.#activeLine = line.index;\n            }\n\n            this.#onSync(line, word);\n      }\n\n      /**\n       * listen to lyricle event\n       * @param {string} event - event name\n       * @param {function} callback - event callback\n       */\n      on(event, callback) {\n            if (typeof callback != \"function\") {\n                  throw Error(\"Liricle.on(): 'callback' argument must be a function!\");\n            }\n\n            switch (event) {\n                  case \"init\":\n                        this.#onInit = callback;\n                        break;\n                  case \"sync\":\n                        this.#onSync = callback;\n                        break;\n            }\n      }\n}\n"],"names":["TAGS_REGEX","WORD_REGEX","LINE_TIME_REGEX","WORD_TIME_REGEX","parser","text","lines","split","output","tags","enhanced","isEnhanced","forEach","value","match","name","trim","extractTags","line","times","bucket","push","time","extractTime","extractText","words","extractWords","extractLine","sort","a","b","sortLines","replace","min","sec","parseFloat","convertTime","test","sync","data","word","index","getClosestIndex","findLine","findWord","items","scores","item","score","length","smallest","Math","indexOf","activeLine","activeWord","onInit","onSync","constructor","this","async","options","url","resp","fetch","ok","Error","status","statusText","body","error","message","offset","continuous","undefined","on","event","callback"],"mappings":"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"}