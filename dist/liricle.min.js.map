{"version":3,"file":"liricle.min.js","sources":["../src/parser.js","../src/syncher.js","../src/liricle.js"],"sourcesContent":["// will match: \"[tag:value]\"\nconst TAGS_REGEX = /\\[(ar|ti|al|au|by|length|offset|re|ve):(.*)\\]/i;\n\n// will match: \"<00:00.00> blablabla\"\nconst WORD_REGEX = /<\\d{2}:\\d{2}(.\\d{2,})?>\\s*[^\\s|<]*/g;\n\n// will match: \"[00:00.00]\"\nconst LINE_TIME_REGEX = /\\[\\d{2}:\\d{2}(.\\d{2,})?\\]/g;\n\n// will match: \"<00:00.00>\"\nconst WORD_TIME_REGEX = /<\\d{2}:\\d{2}(.\\d{2,})?>/g;\n\n/**\n * parse lrc to javascript object\n * @param {string} text - lrc text\n * @returns {Object} parsed lrc data\n */\nexport default function parser(text) {\n      const lines = text.split(/\\r?\\n/);\n\n      const output = {\n            tags: {},\n            lines: [],\n            enhanced: isEnhanced(text)\n      };\n\n      // parsing started\n      lines.forEach(value => {\n            const tags = extractTags(value);\n            const line = extractLine(value);\n\n            if (tags) output.tags[tags.name] = tags.value;\n            if (line) output.lines.push(...line);\n      });\n\n      // if lrc has multiple timestamps \"[mm:ss.xx]\" in the same line\n      // parser will split into individual lines\n      // so we have to reorder them.\n      output.lines = sortLines(output.lines);\n\n      return output;\n}\n\n/**\n * extract tag data from lrc\n * @param {string} text - lrc line\n * @return {(Object|undefined)} extrated tag object or undefined\n */\nfunction extractTags(text) {\n      const tags = text.match(TAGS_REGEX);\n\n      if (!tags) return;\n\n      return {\n            name: tags[1],\n            value: tags[2].trim()\n      };\n}\n\n/**\n * extract time, text and words from lrc\n * @param {string} line - lrc line\n * @return {(Array|undefined)} array that contains lrc line object or undefined\n */\nfunction extractLine(line) {\n      const times = line.match(LINE_TIME_REGEX);\n      const bucket = [];\n\n      if (!times) return;\n\n      times.forEach(value => {\n            bucket.push({\n                  time: extractTime(value),\n                  text: extractText(line),\n                  words: extractWords(line)\n            });\n      });\n\n      return bucket;\n}\n\n/**\n * extract time from lrc line and convert to seconds\n * @param {string} timestamp - time string \"[mm:ss.xx]\"\n * @returns {number} extracted time number in seconds\n */\nfunction extractTime(timestamp) {\n      let time = timestamp.replace(/\\[|\\]|<|>/g, \"\");\n      time = convertTime(time);\n\n      return time;\n}\n\n/**\n * extract text from lrc line\n * @param {string} line - lrc line\n * @returns {string} extracted text\n */\nfunction extractText(line) {\n      let text = line.replace(LINE_TIME_REGEX, \"\");\n      text = text.replace(WORD_TIME_REGEX, \"\");\n      text = text.replace(/\\s{2,}/g, \" \");\n\n      return text.trim();\n}\n\n/**\n * extract words from lrc line\n * @param {string} line - lrc line\n * @returns {(Array|null)} extracted words or null\n */\nfunction extractWords(line) {\n      const words = line.match(WORD_REGEX);\n      const bucket = [];\n\n      if (!words) return null;\n\n      words.forEach(value => {\n            // extract timestamp \"<00:00.00>\" with regex\n            // i think it's easier than split them\n            const time = value.match(WORD_TIME_REGEX)[0];\n\n            bucket.push({\n                  time: extractTime(time),\n                  text: extractText(value)\n            });\n      });\n\n      return bucket;\n}\n\n/**\n * convert \"03:24.73\" to 204.73 (total time in seconds)\n * @param {string} time - time string \"mm:ss.xx\"\n * @returns {number} total time in secondsi\n */\nfunction convertTime(time) {\n      let [min, sec] = time.split(\":\");\n\n      min = parseFloat(min) * 60;\n      sec = parseFloat(sec);\n\n      return min + sec;\n}\n\n/**\n * sort lines by time (shortest to longest)\n * @param {Array} lines - array of lrc lines objects\n * @returns {Array} sorted lines\n */\nfunction sortLines(lines) {\n      return lines.sort((a, b) => a.time - b.time);\n}\n\n/**\n * check the lrc format is enhanced or not\n * @param {string} text - lrc text\n * @returns {boolean} is enhanced?\n */\nfunction isEnhanced(text) {\n      return WORD_TIME_REGEX.test(text);\n}\n","/**\n * find closest lyric word and line from given time\n * @param {Object} data - output data from parser\n * @param {number} time - current time from audio player or something else\n */\nexport default function syncher(data, time) {\n      let line = null;\n      let word = null;\n\n      const lines = data.lines;\n      line = findLine(lines, time);\n\n      if (line != null && data.enhanced) {\n            const words = line.words;\n            word = findWord(words, time);\n\n            // delete 'words' property from line\n            // because we don't need it anymore.\n            delete line.words;\n      }\n\n      return { line, word };\n}\n\n/**\n * find closest lyric line\n * @param {Array} lines - array of lrc lines object\n * @param {number} time - time argument\n * @returns {(Object|null)} closest lyric line or null\n */\nfunction findLine(lines, time) {\n      const index = getClosestIndex(lines, time);\n      return index != null ? { index, ...lines[index] } : null;\n}\n\n/**\n * find closest lyric word\n * @param {Array} words - array of lrc line words object\n * @param {number} time - time argument\n * @returns {(Object|null)} closest lyric word or null\n */\nfunction findWord(words, time) {\n      // if words are null, just return it.\n      if (words == null) return words;\n\n      const index = getClosestIndex(words, time);\n      return index != null ? { index, ...words[index] } : null;\n}\n\n/**\n *\n * @param {Array} items - array that contains lrc words or lines\n * @param {number} time - time argument\n * @returns {(number|null)} closest index of lyric or null\n */\nfunction getClosestIndex(items, time) {\n      // to find the closest index we just need to subtract each line or word time with the given time\n      // then put the value into an array and find the smallest positive value with Math.min()\n      // after that we can find the index from smallest value in array with indexOf() method.\n\n      const scores = [];\n\n      items.forEach(item => {\n            const score = time - item.time;\n            if (score >= 0) scores.push(score);\n      });\n\n      if (scores.length == 0) return null;\n\n      const smallest = Math.min(...scores);\n      const index = scores.indexOf(smallest);\n\n      return index;\n}\n","import parser from \"./parser.js\";\nimport syncher from \"./syncher.js\";\n\nexport default class Liricle {\n      #activeLine = null;\n      #activeWord = null;\n      #offset = 0;\n      #data = {};\n      #onLoad = () => {};\n      #onSync = () => {};\n\n      get data() {\n            return this.#data;\n      }\n\n      get offset() {\n            return this.#offset;\n      }\n\n      /**\n       * @param {number} value - lyric offset in milliseconds\n       */\n      set offset(value) {\n            value = parseFloat(value) / 1000; // convert value to seconds\n            this.#offset = value || 0; // if value is NaN, set 0\n      }\n\n      /**\n       * method to load lyric\n       * @param {Object} options - object that contains 'url' or 'text' properties\n       * @param {string} options.text - lrc text\n       * @param {string} options.url - lrc file url\n       */\n      load(options = {}) {\n            if (options.text) { \n                  this.#data = parser(options.text);\n                  this.#onLoad(this.#data);\n            }\n            \n            if (options.url) {\n                  fetch(options.url)\n                        .then(res => res.text())\n                        .then(text => {\n                              this.#data = parser(text);\n                              this.#onLoad(this.#data);\n                        })\n                        .catch(error => {\n                              throw Error(\"failed to load lyric file. \" + error.message);\n                        });\n            }\n      }\n\n      /**\n       * method to sync lyric\n       * @param {number} time - current player time or something else in seconds\n       * @param {boolean} [continuous] - always emit sync event (optional)\n       */\n      sync(time, continuous = false) {\n            const { line, word } = syncher(this.data, time + this.offset);\n            const { enhanced } = this.data;\n\n            if (line == null && word == null) return;\n\n            if (continuous) {\n                  return this.#onSync(line, word);\n            }\n\n            const isSameLine = line.index == this.#activeLine;\n            const isSameWord = word != null && word.index == this.#activeWord;\n\n            if (enhanced && word != null) {\n                  if (isSameLine && isSameWord) return;\n            } else { \n                  if (isSameLine) return;\n            }\n\n            this.#onSync(line, word);\n\n            this.#activeLine = line.index;\n            this.#activeWord = word != null ? word.index : null;\n      }\n\n      /**\n       * listen to liricle event\n       * @param {string} event - event name\n       * @param {function} callback - event callback\n       */\n      on(event, callback) {\n            switch (event) {\n                  case \"load\":\n                        this.#onLoad = callback;\n                        break;\n                  case \"sync\":\n                        this.#onSync = callback;\n                        break;\n            }\n      }\n}\n"],"names":["TAGS_REGEX","WORD_REGEX","LINE_TIME_REGEX","WORD_TIME_REGEX","parser","text","lines","split","output","tags","enhanced","isEnhanced","forEach","value","match","name","trim","extractTags","line","times","bucket","push","time","extractTime","extractText","words","extractWords","extractLine","sort","a","b","sortLines","timestamp","replace","min","sec","parseFloat","convertTime","test","syncher","data","word","index","getClosestIndex","findLine","findWord","items","scores","item","score","length","smallest","Math","indexOf","activeLine","activeWord","offset","onLoad","onSync","this","load","options","url","fetch","then","res","catch","error","Error","message","sync","continuous","isSameLine","isSameWord","on","event","callback"],"mappings":"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"}