{"version":3,"file":"liricle.min.js","sources":["../src/parser.js","../src/sync.js","../src/liricle.js"],"sourcesContent":["// will match: \"[name:value]\"\nconst TAGS_REGEX = /\\[([a-z]+):(.+)\\]/i;\n\n// will match: \"[00:00.00]\" one or more.\nconst TIME_REGEX = /\\[\\d{2}:\\d{2}(.\\d{2,})?\\]{1,}/g;\n\n// will match: \"<00:00.00> blablabla\".\nconst WORD_REGEX = /(<\\d{2}:\\d{2}.\\d{2,}>\\s{0,}([^\\s]+))/g;\n\n// only match: \"<00:00.00>\". mainly used to extract time.\nconst WORD_TIME_REGEX = /<\\d{2}:\\d{2}(.\\d{2,})?>/;\n\nconst output = {\n      lines: [],\n      tags: {},\n      enhanced: false,\n};\n\n/**\n * LRC parser\n * @param {string} lrc - LRC text\n * @returns {Object} output\n */\nfunction parser(lrc) {\n      // check if the lrc file is enhanced or not\n      if (WORD_TIME_REGEX.test(lrc)) {\n            output.enhanced = true;\n      }\n\n      const lines = lrc.split(/\\r|\\n/);\n\n      // parsing started\n      lines.forEach((line) => {\n            parseTags(line);\n            parseLine(line);\n      });\n\n      output.lines = sortLines(output.lines);\n      return output;\n}\n\n/**\n * parse tags data from LRC file\n * @param {string} line - LRC line\n */\nfunction parseTags(line) {\n      const match = line.match(TAGS_REGEX);\n\n      if (match == null) return;\n\n      const name = match[1];\n      const value = match[2].trim();\n\n      // push data to output\n      output.tags[name] = value;\n}\n\n/**\n * parse line from LRC file\n * @param {string} line - LRC line\n */\nfunction parseLine(line) {\n      const match = line.match(TIME_REGEX);\n\n      if (match == null) return;\n\n      match.forEach((value) => {\n            // push data to output\n            output.lines.push({\n                  time: convertTime(value),\n                  text: extractText(line),\n                  words: parseWords(line)\n            });\n      });\n}\n\n/**\n * parse words from enhanced LRC\n * @param {string} line - LRC line\n * @returns {Array} parsed words\n */\nfunction parseWords(line) {\n      const match = line.match(WORD_REGEX);\n      const words = [];\n\n      if (match == null) return null;\n\n      match.forEach((value) => {\n            // extract timestamp. \"<00:00.00>\"\n            // i think it's easier than split them.\n            const time = value.match(WORD_TIME_REGEX)[0];\n\n            words.push({\n                  time: convertTime(time),\n                  text: extractText(value),\n            });\n      });\n\n      return words;\n}\n\n/**\n * extract text / lyric from timed line\n * @param {string} line - LRC line\n * @returns {string} extracted text\n */\n function extractText(line) {\n      // remove timestamp\n      line = line.replace(TIME_REGEX, \"\");\n      line = line.replace(WORD_REGEX, \"$2\");\n\n      return line.trim();\n}\n\n/**\n * convert \"[03:24.73]\" => 204.73 (total time in seconds)\n * @param {string} time - string time \"[mm:ss.xx]\" or \"<mm:ss.xx>\"\n * @returns {number} total time in seconds\n */\nfunction convertTime(time) {\n      time = time.replace(/\\[|\\]|<|>/g, \"\");\n      time = time.split(\":\");\n\n      let [min, sec] = time;\n\n      min = parseInt(min) * 60;\n      sec = parseFloat(sec);\n\n      return min + sec;\n}\n\n/**\n * sort lines from shortest to longest\n * @param {Array} lines - parsed lines\n * @returns {Array} sorted lines\n */\nfunction sortLines(lines) {\n      return lines.sort((a, b) => a.time - b.time);\n}\n\nexport default parser;\n","/**\n * find closest lyric index from given time\n * @param {Object} data - output data from parser\n * @param {number} time - currrent time from audio player or something in seconds\n * @returns {Object} - the current lyric line and word\n */\nfunction sync(data, time) {\n      let line = findLine(data, time);\n      let word = line != null && data.enhanced ? findWord(line, time) : null;\n\n      // delete words property from line\n      if (line != null) delete line.words;\n\n      return { line, word };\n}\n\n/**\n * find closest line\n * @param {Object} data \n * @param {number} time - currrent time\n * @returns {Object|null}\n */\nfunction findLine(data, time) {\n      const lines = data.lines;\n      const index = getClosestIndex(lines, time);\n\n      return index != null ? { index, ...lines[index] } : null;\n}\n\n/**\n * find closest word\n * @param {Object} line \n * @param {number} time - currrent time\n * @returns {Object|null}\n */\nfunction findWord(line, time) {\n      const words = line.words;\n\n      // hanlde if line not contain timed words.\n      if (words == null) return null;\n\n      const index = getClosestIndex(words, time);\n\n      return index != null ? { index, ...words[index] } : null;\n}\n\n/**\n * find closest lyric index\n * @param {Array} data \n * @param {number} time - currrent time \n * @returns {number|null} index of lyric\n */\nfunction getClosestIndex(data, time) {\n      // to find the closest index we just need to subtract each line or word time with the given time\n      // then put the value into an array and find the smallest positive value with Math.min()\n      // after that we can find the index from smallest value in array with indexOf() method.\n\n      const scores = [];\n\n      data.forEach((item) => {\n            const score = time - item.time;\n            if (score >= 0) scores.push(score);\n      });\n\n      if (scores.length == 0) return null;\n\n      const smallest = Math.min(...scores);\n      const index = scores.indexOf(smallest);\n\n      return index;\n}\n\nexport default sync;\n","import parser from \"./parser.js\";\nimport sync from \"./sync.js\";\n\nclass Liricle {\n      constructor() {\n            this.activeLine = null;\n            this.activeWord = null;\n            this.onInit = () => {};\n            this.onSync = () => {};\n\n            this.data = null;\n      }\n\n      /**\n       * initialize Liricle\n       * @param {Object} options\n       * @param {string} options.text - LRC text\n       * @param {string} options.url - LRC file url\n       */\n      async init({ text, url }) {\n            let lrc = text;\n\n            if (url) {\n                  try {\n                        const resp = await fetch(url);\n                        const body = await resp.text();\n\n                        lrc = body;\n                  } \n                  \n                  catch (error) { throw Error(error) }\n            }\n\n            this.data = parser(lrc);\n            this.onInit(this.data);\n      }\n\n      /**\n       * sync lyric with current time\n       * @param {number} time - currrent time from audio player or something in seconds\n       * @param {number} offset - lyric offset in seconds\n       */\n      sync(time, offset = 0, continuous = false) {\n            const { line, word } = sync(this.data, time + offset);\n            \n            if (line == null && word == null) return;\n\n            if (this.data.enhanced && word != null) {\n                  if (\n                        continuous == false &&\n                        line.index == this.activeLine &&\n                        word.index == this.activeWord\n                  ) return;\n\n                  this.activeLine = line.index;\n                  this.activeWord = word.index;\n            }\n\n            else {\n                  if (\n                        continuous == false &&\n                        line.index == this.activeLine\n                  ) return;\n                  \n                  this.activeLine = line.index;\n            }\n\n            this.onSync(line, word);\n      }\n\n      /**\n       * add event listener\n       * @param {string} event - event name\n       * @param {function} callback - event callback\n       */\n      on(event, callback) {\n            if (typeof callback != \"function\") {\n                  throw Error(\"callback must be a function!\");\n            }\n\n            switch (event) {\n                  case \"init\":\n                        this.onInit = callback;\n                        break;\n                  case \"sync\":\n                        this.onSync = callback;\n                        break;\n            }\n      }\n}\n\nexport default Liricle;\n"],"names":["TAGS_REGEX","TIME_REGEX","WORD_REGEX","WORD_TIME_REGEX","output","lines","tags","enhanced","parser","lrc","test","split","forEach","line","match","name","value","trim","parseTags","push","time","convertTime","text","extractText","words","parseWords","parseLine","sort","a","b","sortLines","replace","min","sec","parseInt","parseFloat","sync","data","index","getClosestIndex","findLine","word","findWord","scores","item","score","length","smallest","Math","indexOf","constructor","this","activeLine","activeWord","onInit","onSync","async","url","resp","fetch","error","Error","offset","continuous","on","event","callback"],"mappings":"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"}